# summary1

## 线程间通讯

1. 互斥量(mutex)
2. 读写锁(rwlock)
3. 条件变量(cond)
4. 信号量(semaphore)

## io

1. 阻塞io
2. 非阻塞IO
   - 需要轮询
3. io复用, reactor
   - select,epoll,poll.设置为非阻塞,由内核确定io准备就绪,然后应用读取数据
4. 信号驱动io
   - 注册信号回调,内核在io准备就绪时发送信号,调用指定回调读取数据
5. 异步IO,Proactor
   - 内核处理完io后,通知应用io完成,应用不需要读取数据

## 常见网络服务器并发模型

- 单线程循环
  - 阻塞串行
- 多线程/多进程
  - 线程池处理io&业务
- 单线程IO复用
- 多线程/多进程IO复用
- 多线程划分IO角色
  - io 线程
  - handler线程
- AIO
- 协程

## db

### sql 执行过程

1. 客户端发送请求
2. 服务端检查cache,命中直接返回
3. 解析
4. 预处理
5. 优化器
6. 执行查询
7. 返回结果

### MySQL缓存失效

1. sql语句hash值为key,大小写敏感
2. 对表修改
3. 不使用任何表查询语句 `select "A"`
4. 查询mysql，information_schema或performance_schema数据库中的表时,不会走查询缓存
5. 在存储的函数,触发器或事件的主体内执行的查询

### varchar(n) char(n)

1. 4.0版本以下，varchar(20)，指的是20字节，如果存放UTF8汉字时，只能存6个
2. 5.0版本以上，varchar(20)，指的是20字符，无论存放的是数字、字母还是UTF8汉字，都可以存放20个
3. varchar 可变长
4. char不可变长,中文只能存 n/3个字符

### InnoDB 幻读处理

1. MVCC(多版本并发控制) 事务版本号管理
   - 每一行隐藏两列,一列数据行版本号,还有删除版本号
   - 在某个瞬间看到的是数据库的一个快照,写操作在提交前其他事务无法观察到
   - 更新操作: 标记过时,别处新增数据
   - 读操作: 读取一列的版本号小于当前版本号的列
   - 版本号一般为时间戳或者事务id
2. 间隙锁(gap):锁定一个范围
3. 行锁(Record Lock):单个行记录的锁
4. Next-Key Lock(3+4):锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题
5. 在select for update时,select时使用MVCC,导致读到的是旧数据,更新时却是在新数据之上更新的,所以是无法处理幻读情况

### redo log, bin log

1. redo log可用于数据恢复,bin log不行
2. binlog记录语句原始逻辑,是逻辑日志; redolog是物理日志,记录数据页更新记录
3. redolog是循环写,日志空间大小固定;binlog是追加写,到一定大小更换文件
4. binlog可以用于主从搭建

### 行迁移 行链接

行迁移: 可用空间<10%,这个数据块不可插入,在原行位置填写rowid,在别的地方放数据
行链接: 行数据过大,需要拆分

### 聚簇索引和非聚簇索引

聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针

### b, b+

b树非叶子节点会存放数据
b+树数据只会在叶子节点,叶子节点会有链接

### 索引失效

1. 条件中含有or,
2. 存储引擎不能继续使用索引中范围条件,between,<,>,in
3. 多列索引,不满足最左
4. like以%开头
5. 查询列过多
6. 索引字段上使用 !=, <, >, is null, is not null
7. 索引字段是字符串,但查询时不加单引号

## os

### 进程&线程

1. 调度
    - 进程是系统资源分配和调度的独立单元
    - 线程是CPU调度和分派的基本单位
2. 进程之间是相互独立的.线程挂了会导致整个进程挂掉
3. 资源
   - 进程之间不能共享自己的资源
   - 线程共享所在进程的地址空间和其他资源;线程还拥有自己的栈&栈指针,多种寄存器,局部变量和金泰存储空间
4. 创建
   - 线程创建速度快于进程
5. 运行状态
   - 线程没有挂起状态,挂起是对整个进程来说的
   - 就绪,阻塞,运行

6. linux:
   - 线程是轻量级进程,用户线程被映射到共享同一个组id的多个linux内核级进程上,共享文件和内存等资源(使用clone())

### 磁盘

> libc -> VFS -> FS

1. 发起请求
2. 通过fd定位到VFS已打开文件列表的项
3. 系统调用read
4. 根据文件路径到目录项模块找到inode
5. 通过inode找到对应的address_space
6. address_space访问文件页缓存树
   1. 成功则返回
   2. 失败则触发缺页中断,然后通过inode找到文件
7. 读取成功

#### 文件读操作

1. 系统调用发起读请求
2. 检查进程的文件描述符定位到VFS打开文件列表的项,如果已被打开,则分配一个新的结构,并把结构指向文件
3. 调用read()调用
4. 在目录项模块中,根据文件路径检索,找到文件的inode
5. 根据偏移量算出所需页
6. 通过inode找到文件对应的address_space
   1. 命中页缓存,直接退出
   2. 否则,发起缺页中断,根据inode定位到文件所在物理位置,载入后再执行6
7. 结束

#### 文件写操作

1. 前5步和读一致
2. 通过inode找到文件对应的address_space
   1. 命中页缓存,直接写,设置标志位,退出
   2. 否则,发起缺页中断,根据inode定位到文件所在物理位置,载入后再执行6
3. 异步把脏页写入磁盘

#### VFS

1. 超级块.用于保存文件系统所有元数据,一个超级块可代表一个文件系统.常驻内存
2. 目录项模块.存放目录下所有文件的inode和信息
3. inode模块.管理一个具体文件,是文件唯一标识
4. 打开文件列表模块.包含所有已打开文件
5. file_operations模块.链接一系列函数指针的集合,包含open read write mmap等
6. address_space.一个文件在页缓存中已经缓存

分配inode时,系统至少会再分配一个block存放文件名,目录名等数据

#### inode

1. 只包含元数据,不包含文件名和目录名
   1. 存取模式
   2. 拥有者与群组
   3. 容量
   4. 创建或状态改变的时间
   5. 最近一次的读取时间
   6. 最近修改的时间
   7. 定义文件特性的旗标（flag）
   8. 该文件真正内容的指向 （pointer）

#### ext文件系统

1. 启动扇区(boot sector)
2. 区块群组(block group)
   1. 超级块(Superblock)
      1. block和inode的总容量
      2. 已使用和剩余block和inode数量
      3. block 与 inode 的大小
      4. file system挂载时间,写和检测时间
      5. 是否已挂载的标志位
   2. 档案系统描述(Filesystem Description)
      1. 描述每个block group的开始和结束block号码以及说明每个区段 （superblock, bitmap, inodemap, data block） 分别介于哪一个 block 号码之间
   3. 区块对应表(block bitmap)
      1. 标记某个块是否被占用
   4. inode对应表(inode bitmap)
      1. 标记某个inode是否被占用
   5. inode table
   6. Data block

### Linux内存管理

1. 伙伴系统(页内存管理)
   - 三级页表结构:
     - 页目录
     - 页中间目录
     - 页表
   - 时钟算法,最少使用频率
2. slab
   - 链表管理,块雷士伙伴算法的方式合并或分裂,可以在链表间移动

### thread_local

每条线程拥有自己的内存空间,使用`pthread_key_create` 和 `pthread_key_delete` 构建和析构线程私有变量,通过  `pthread_getspecific` 获取变量值

### mmap

1. 用户空间调用mmap
2. 在当前虚拟地址空间分配一段连续的空闲地址
3. 分配vm_area_struct并初始化
4. 将vm_area_struct插入到进程虚拟地址区域链表
5. 在文件描述符表中找到对应文件描述符，找到文件结构体
6. 通过文件结构体，链接到file_operations，内核调用mmap
7. 通过inode定位到物理地址
8. 建立页表，实现对文件物理地址和虚拟地址的映射关系
9. 读、写文件，引发缺页中断

常规文件操作需要磁盘->页缓存->用户主存,mmap是磁盘->用户主存

### 软链接 硬链接

1. 软链接是一个特殊的文件,文件内容为被链接文件的路径信息,被链接文件如果被删掉,发起写请求会新建
2. 硬链接是以引用计数为基础的inode引用,删除被链接文件,文件仍能正常存在

### TCP接收端滑动窗口为0

1. 发送端定时尝试1字节包,探测接收端滑动窗口是否正常
2. 超时的话,继续等待并尝试
3. 失败次数过多,发送rst,关闭连接,通知应用层错误

## c++

### 不用final实现不可继承

私有化构造函数

### memory ordering

- memory_order_relaxed
  - 只保证load和store的原子性,不提供任何跨线程的同步
- memory_order_consume
  - 后面依赖此原子变量的访存指令勿重排至此条指令之前
- memory_order_acquire
  - 后面访存指令勿重排至此条指令之前
- memory_order_release
  - 前面访存指令勿重排至此条指令之后。当此条指令的结果对其他线程可见后，之前的所有指令都可见
- memory_order_acq_rel
  - acquire + release语意
- memory_order_seq_cst
  - acq_rel语意外加所有使用seq_cst的指令有严格地全序关系

## 计网

### tls握手

1. client hello 支持的加密套件,随机数,请求域名,tls版本号等
2. server hello 商定的加密方法,随机数,tls版本号
3. Server Certificate ca证书
4. Server Key Exchange 如果前几步商定的数据不足以进行密钥交换,那就在这里商定
5. Server Hello Done 服务端相应完成,等待客户端
6. client Certificate 客户端确定ca证书是否合法,这步不与服务端交互
7. Client Key Exchange 服务端发送通过公钥加密的随机数
8. Change Cipher Spec 客户端发送信息,接下来使用对称加密
9. Finished 双方都发送并验证数据,确定密钥可用

## 其他

### 令牌桶

- 一个桶存放固定数量的令牌,固定间隔往桶里存放令牌,超过容量不再增加
- 每次请求需要获取令牌后才可操作,否则丢弃请求
- 对突发流量有更好的效果

### 漏桶

- 请求都放到队列里面,超过队列容量直接丢弃
- 获取队列内的请求是恒速的

### 设计高并发系统

- 系统拆分
- 缓存
- 数据库分库分表
- 读写分离
- 分布式易扩容

### 缓存更新策略

#### Cache Aside Pattern

1. 写磁盘
2. 删缓存

#### Read/Write Through Pattern

1. 读写缓存
2. 系统写磁盘

#### Write Behind Caching Pattern

1. 读写缓存
2. 异步写磁盘，多次写操作可能会被合并为一次写磁盘
