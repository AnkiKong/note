# 汇编

## 第二章

### 通用寄存器

- 数据寄存器
  - AX –accumulator register
    - AH、AL
  - BX –base register
    - BH、BL
  - CX –count register
    - CH、CL
  - DX –data register
    - DH、DL
- 变址寄存器index registers:
  - SI:source index register
  - DI:destination index register
- 指针寄存器
  - SP:stack pointer register
  - BP:base pointer register

### 标志寄存器

|标志名|标志为1时|标志为0时|
|---|---|---|
|OF[Overflow Flag]|ov[OVerflow]|nv[Not oVerflow]|
|DF[Direction Flag]|dn[DowN]|up[UP]|
|IF[Interrupt Flag]|ei[Enable I~t]|di[Disable I~t]|
|SF[Sign Flag]|ng[NeGative sign]|pl[PLus sign]|
|ZF[Zero Flag]|zr[ZeRo]|nz[Not Zero]|
|AF[Auxiliary carry Flag]|ac[Auxiliary Carry]|na[Not Aux~]|
|PF[Parity Flag]|pe[Parity Even]|po[Parity Odd]|
|CF[Carry Flag]|cy[CarrY]|nc[Not Carry]|

### 地址

- 物理地址：每个存储单元的唯一的20位地址
- 段地址：段起始地址的高16位
- 偏移地址：段内相对于段起始地址的偏移值（16位）(有效地址EA)  
- 物理地址 = 16d * 段地址 + 偏移地址

## 第三章

### 8086寻址

1. 立即寻址方式 —— 操作数在指令中给出
   - MOV AH, 3030H
   - 只能用于 SRC 字段
   - SRC 和 DST 的字长一致
2. 寄存器寻址方式 — 操作数在指定的寄存器中
   - MOV  AX, BX
   - 字节寄存器只有，AH  AL  BH  BL  CH  CL  DH  DL
   - SRC 和 DST 的字长一致
   - CS 不能用 MOV 指令改变
3. 直接寻址方式 — 有效地址EA由指令直接给出
   - MOV AX, [2000H]
   - 隐含的段为数据段 DS, 等价于 MOV AX, DS:[2000H]
   - 可使用段跨越前缀 MOV  AX, ES:[2000H]
   - 操作数地址可由变量（符号地址）表示, 但要注意变量的属性
   - 两操作数不能同时为存取器操作数
4. 寄存器间接寻址 — EA 在基址寄存器(BX/BP)或变址寄存器(SI/DI)中
   - MOV AX, [BX]
   - 不允许使用AX、CX、DX 存放 EA
   - SRC 和 DST 的字长一致
   - 适于数组、字符串、表格的处理
   - 段跨越前缀：默认DS:[BX], SS:[BP], DS:[SI], DS:[DI]
5. 寄存器相对寻址方式
   - MOV AX, COUNT[SI] 或 MOV AX, [COUNT+SI]
   - BX, BP, SI, DI,对应方式同(4
   - 适于数组、字符串、表格的处理
   - 支持段跨越前缀
    >假设 (DS)=3000H, (SI)=2000H, COUNT=3000H,则: PA = 35000H
6. 基址变址寻址方式
   - MOV AX,[BX][DI] 或 MOV AX, [BX+DI] 或 MOV AX, ES:[BX][SI]
   - 适于数组、字符串、表格的处理
   - 必须是一个基址寄存器(BX/BP)和一个变址寄存器的组合(SI/DI)
   - 支持段跨越前缀
7. 相对基址变址寻址方式
   - MOV AX, MASK[BX][SI]
   - 支持段跨越前缀

#### 默认段寄存器的使用规定

|访问存储器的方式|默认的段寄存器|可跨越的段寄存器|偏移地址|
|---|---|---|---|
|取指令|CS|无|IP|
|堆栈操作|SS|无|SP|
|一般数据访问|DS|CS  ES  SS|BX SI DI EA|
|BP作为基址的寻址|SS|CS  DS  ES|BP|
|串操作的源操作数|DS|CS  ES  SS|SI|
|串操作的目的操作数|ES|无|DI|

### 8086的指令系统

#### 通用数据传送指令MOV

- 通用数据传送指令MOV
- 传送指令：`MOV DST, SRC`
  - DST、SRC 不能同时为段寄存器 MOV  DS, ES
  - 立即数不能直接送段寄存器 MOV  DS, 2000H
  - DST 不能是立即数和CS
  - DST、SRC 不能同时为存储器寻址
  - 不影响标志位

#### 进栈PUSH(push onto the stack)指令/出栈POP(Pop from  the stack)指令

- PUSH执行操作：(SP)<-(SP)–2 ; ((SP)+1, (SP))<-(SRC)
- POP执行操作：(DST)<-((SP)+1, (SP)) ; (SP)<-(SP) + 2
  - ‘先进后出’的存储区，段地址存放在SS中，SP在任何时候都指向栈顶，进出栈后自动修改SP。
  - 堆栈操作必须以字或双字为单位。
  - 不影响标志位
  - 16位不能用立即寻址方式，但32位的允许
  - DST不能是CS

##### 所有通用寄存器进栈PUSHA/PUSHAD指令：PUSHA/PUSHAD/所有寄存器出栈POPA/POPAD指令

- 执行操作：AX/EAX,CX/ECA,DX/EDX,BX/EBX,指令执行前的SP/ESP,BP/EBP,SI/ESI,DI/EDI依次进栈
- 执行操作：16位或32位通用寄存器按进栈的相反顺序出栈

#### 交换XCHG(exchange)指令

- `XCHG OPR1, OPR2`
- 执行操作：(OPR1)<->(OPR2)
  - 在寄存器和存储器之间交换
  - 起码有一个操作数是寄存器操作数
  - 不影响标志位
  - 不允许使用段寄存器

#### 输入input指令 IN/ 输出output指令 OUT

- IN (input)（I/O -> CPU）
  - 长格式：`IN AL, PORT`（字节）`IN AX, PORT`（字）
    - 执行操作：(AL)<-(PORT)（字节）(AX)<-(PORT+1, PORT)（字）
  - 短格式：`IN AL, DX`（字节）`IN AX, DX`（字）
    - 执行操作：(AL)<-((DX))（字节）(AX)<-((DX)+1, (DX))（字）
- OUT (output)（CPU <- I/O）
  - 长格式：`OUT PORT, AL`（字节）`OUT PORT, AX`（字）
    - 执行操作：(AL)->(PORT)（字节）(AX)->(PORT+1, PORT)（字）
  - 短格式：`OUT DX, AL`（字节）`OUT DX, AX`（字）
    - 执行操作：(AL)->((DX))（字节）(AX)->((DX)+1, (DX))（字）
- 不影响标志位
- 前256个端口号00H~FFH可直接在指令中指定（长格式）
- 如果端口号 >= 256，**端口号 -> DX**（短格式）

#### 换码translate指令 XLAT

- `XLAT`  或　`XLAT OPR`
  - 执行操作：(AL)<-((BX)+(AL))
- 不影响标志位
- 字节表格(长度不超过256) 首地址 -> **(BX)**
- 需转换的代码位移量 -> (AL)

#### 地址传送指令

- LEA
  - `LEA BX, [BX+SI+0F62H]`

#### 类型转换指令

- `CBW`(convert byte to word)
  - 若(AL)的最高有效位为0，则(AH)= 00H
  - 若(AL)的最高有效位为1，则(AH)= FFH
- `CWD`(convert word to double word)
  - 若(AX)的最高有效位为0，则(DX)= 0000H
  - 若(AX)的最高有效位为1，则(DX)= FFFFH
- 无操作数指令
- 隐含对AL 或AX 进行符号扩展
- 不影响条件标志位

#### 加法指令

- `ADD DST, SRC`
  - (DST)<-(SRC)+(DST)
- `ADC DST, SRC`
  - (DST)<-(SRC)+(DST)+CF
- `INC OPR`
  - (OPR)<-(OPR)+1
- **除INC指令不影响CF标志外，均对条件标志位有影响。**
- CF 位表示 无符号数 相加的溢出。
- OF 位表示 带符号数 相加的溢出。

#### 减法指令

- `SUB DST, SRC`
  - (DST)<-(DST)-(SRC)
- `SBB DST, SRC`
  - (DST)<-(DST)-(SRC)-CF
- `DEC OPR`
  - (OPR)<-(OPR)-1
- `NEG OPR`
  - (OPR) <- -(OPR)
- 除DEC指令不影响`CF`标志外，均对条件标志位有影响
- CF 位表示 无符号数 减法的溢出。
- OF 位表示 带符号数 减法的溢出。

#### 乘法指令

- unsigned multiple无符号数乘法指令 `MUL SRC`
- signed multiple带符号数乘法指令 `IMUL SRC`
  - 字节操作数  (AX) <- (AL)*(SRC)
  - 字操作数    (DX, AX) <- (AX)*(SRC)
- AL(AX) 为隐含的乘数寄存器。
- AX (DX,AX) 为隐含的乘积寄存器。
- SRC不能为立即数。
- 除CF和OF外，对条件标志位无定义。

#### 除法指令

- unsigned divide无符号数除法指令 `DIV SRC`
- signed divide带符号数除法指令 `IDIV SRC`
  - 字节操作  
    - (AL) <- (AX) / (SRC) 的商
    - (AH) <- (AX) / (SRC) 的余数
  - 字操作
    - (AX) <- (DX, AX) / (SRC) 的商
    - (DX) <- (DX, AX) / (SRC) 的余数
- AX (DX,AX) 为隐含的被除数寄存器。
- AL (AX) 为隐含的商寄存器。
- AH (DX) 为隐含的余数寄存器。
- SRC不能为立即数。
- 对所有条件标志位均无定义。

#### 逻辑运算指令

- 逻辑非指令：`NOT OPR`
  - 执行操作: (OPR)<- !(OPR)不影响标志位
- 逻辑与指令：`AND DST, SRC`
  - 执行操作: (DST)<-(DST)&(SRC)
- 逻辑或指令：`OR DST, SRC`
  - 执行操作: (DST)<-(DST)|(SRC)
- 异或指令: `XOR DST, SRC`
  - 执行操作: (DST)<-(DST)^(SRC)
- 测试指令: `TEST OPR1, OPR2`
  - 执行操作: (OPR1)^(OPR2)
- 逻辑左移: `SHL OPR, CNT`
  - CF=0x80 & OPR
  - OPR <<=CNT
- 逻辑右移  `SHR  OPR, CNT`
  - CF=OPR&1
  - OPR >>=CNT
- 算术左移 `SAL OPR, CNT`
  - 同逻辑左移
- 算术右移 `SAR OPR, CNT`
  - CF=OPR&1
  - OPR>>=CNT
  - OPR |= 0x80 & OPR
- 循环左移 `ROL OPR, CNT`
  - 最高位放至最低位
- 循环右移 `ROR OPR, CNT`
  - 最低位放至最高位
- 带进位循环左移 `RCL OPR, CNT`
  - 最高位放至CF
  - CF放至最低位
- 带进位循环右移 `RCR OPR, CNT`
  - 最低位放至CF
  - CF放至最高位

> OPR可用除立即数以外的任何寻址方式
> CNT>1，`MOV  CL, CNT; SHL OPR, CL`
> 移位指令：SF、ZF、PF 根据移位结果设置，AF无定义
> 循环移位指令：不影响 SF、ZF、PF、AF

#### 串处理指令

- 设置方向
  - `CLD` ;DF=0 ;地址增加
  - `STD` ;DF=1 ;地址减少
- 串传送 `MOVS`(B/W); ((DI))<-((SI))
- 串比较 `CMPS`(B/W); ((SI))-((DI))
- 串扫描 `SCAS`(B/W); (AL)-((DI))
- 从串取 `LODS`(B/W); (AL)←((SI))
- 存入串 `STOS`(B/W); ((DI))←(AX)
- `REP` 重复直到CX=0
- `REPZ`/`REPE` 重复直到不相等或CX=0
- `REPNZ`/`REPNE` 重复直到相等或CX=0
- `MOVS ES:BYTE PTR [DI], DS: [SI]`
  - 只存在这种对应关系，串的地址先`LEA`至`Di`和`SI`

#### 子程序调用/返回指令

- CALL
  - (SP)←(SP)-2
  - ((SP)+1,(SP))←(IP)
  - (IP)←(IP)+16位位移量
- CALL 段间直接远调用
  - (SP)←(SP)-2
  - ((SP)+1,(SP))←(CS)
  - (SP)←(SP)-2
  - ((SP)+1,(SP)) ← (IP)
  - (IP) ← 偏移地址
  - (CS) ← 段地址
- RET 段内近返回
  - (IP) ← ( (SP)+1,(SP) )
  - (SP) ← (SP) + 2
- RET 段间远返回
  - (IP) ← ( (SP)+1,(SP) )
  - (SP) ← (SP) + 2
  - (CS) ← ( (SP)+1,(SP) )  
  - (SP) ← (SP) + 2

#### 中断指令

- INT TYPE
  - (SP) ← (SP) - 2
  - ( (SP)+1,(SP) ) ← (FLAGS)
  - (SP) ← (SP) - 2
  - ( (SP)+1,(SP) ) ← (CS)
  - (SP) ← (SP) - 2
  - ( (SP)+1,(SP) ) ← (IP)
  - (IP) ← (TYPE*4)
  - (CS) ← (TYPE*4+2)
- 溢出中断指令：INTO
  - 若OF=1
    - (SP) ← (SP) - 2
    - ( (SP)+1,(SP) ) ← (FLAGS)
    - (SP) ← (SP) - 2
    - ( (SP)+1,(SP) ) ← (CS)
    - (SP) ← (SP) - 2
    - ( (SP)+1,(SP) ) ← (IP)
    - (IP) ← (10H)
    - (CS) ← (12H)
- 从中断返回指令：IRET
  - (IP) ← ( (SP)+1,(SP) )
  - (SP) ← (SP) + 2
  - (CS) ← ( (SP)+1,(SP) )
  - (SP) ← (SP) + 2
  - (FLAGS) ← ( (SP)+1,(SP) )
  - (SP) ← (SP) + 2
- TYPE (0~255) 是中断类型号, 隐含的类型号为3
- INT 指令还把 IF 和 TF 置0，但不影响其它标志位
- IRET 指令执行完，标志位由堆栈中取出的值确定

## 第四章

### 完整段格式

``` ASM
seg_name SEGMENT [align_type] [combine_type] [use_type][‘class’]

seg_name ENDS
```

- align_type
  - para指定该段从小段边界开始；默认值
  - byte指定该段从任一位置开始
  - WORD指定该段从字边界开始
  - page指定该段从页边界开始
- combine_type组合类型
  - PRIVATE 私有段，不合并；默认值
  - PUBLIC  该段连接时将与有相同名字的其他分段连接在一起，仅有一个起始地址
  - COMMON 该段连接时与其他同名分段有相同的起始地址，所以会产生覆盖
  - STACK指定该段为堆栈段
- ‘CLASS’类别
  - 连接时用于组成段组名
