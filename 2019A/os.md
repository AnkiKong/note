# OS  

## 第一章

### 基本指令周期

![基本指令周期](../res/1.jpg)  

>PC保存下一指令地址
>IR指令寄存器

### 中断

中断是一种机制，即允许其它模块（I/O、存储器）在处理器正常处理过程中打断其工作  

#### 中断分类

- 程序中断
- 时钟中断
- I/O中断
- 硬件失效中断

#### 中断和指令周期  

![中断和指令周期](../res/2.jpg)

#### 中断处理

![中断处理](../res/3.jpg)

##### 多中断

- 顺序中断处理: 当正在处理一个中断时，禁止中断
- 嵌套中断处理: 定义中断优先级，允许高优先级的中断打断低优先级的中断处理程序的运行

### 访问的局部性原理

在执行程序期间，处理器的指令访存和数据访存呈现“簇”状(一组数据集合)

#### 二级存取平均时间

cache A, 内存B, 命中率C  
$A*C+(A+B)*(1-C)$  

### I/O操作三种可能的技术

- 可编程I/O
- 中断驱动I/O
- 直接内存存取（DMA）

## 第二章

> 操作系统是控制应用程序执行的程序，并充当应用程序和计算机硬件之间的接口

### OS类型

#### 多道批处理系统

- 内存同时保存多个程序，当一个作业需要等待I/O时，处理器可以切换到另一个不需要等待I/O的作业。
- 提高CPU的利用率。
- 需要中断技术、内存管理、进程调度等方面的支持

#### 分时系统

- 允许多个联机用户同时使用一个计算机系统进行交互式计算。
- 时钟中断，时间片技术

## 第三章 进程描述和控制

>进程定义
>
>- 一个正在执行中的程序。
>- 一个正在计算机上执行的程序实例。
>- 能分配给处理器并由处理器执行的实体。
>- 一个具有以下特征的活动单元：一组指令序列的执行、一个当前状态和相关的系统资源集。
>
>构成进程的基本元素
>
>- 程序代码
>- 数据集
>
>进程控制块(pcb)

### 五态模型、带两挂起

![五态模型](../res/4.jpg)

![带两挂起](../res/5.jpg)

### 进程映像

|项目|说明|
|---|---|
|用户数据|用户空间中的可修改部分，包括程序数据、用户栈区域和可修改的程序|
|用户程序|将被执行的程序|
|系统栈|每个进程有一个或多个系统栈，用于保存参数、过程调用地址和系统调用地址|
|进程控制块|操作系统控制进程所需要的数据|

#### 进程控制块(PCB)

进程标识信息

- 进程ID、父进程ID、用户ID

进程状态信息

- 用户可见寄存器、控制和状态寄存器、栈指针

进程控制信息

- 调度和状态信息、数据结构、进程通信、进程特权、存储管理、资源的所有权和使用情况

### 进程创建

创建进程的步骤

1. 分配进程标识符
2. 分配空间
3. 初始化进程控制块
4. 设置正确的连接
5. 创建或扩充其它数据结构

### 进程切换

> 进程切换是让处于运行态的进程中断运行，让出处理器，让操作系统指定的新进程运行。被中断进程的上下文环境需要保存。

#### 切换时机

1. 中断
   - 时钟中断
   - I/O中断
   - 内存失效
2. 陷阱: 操作系统确定错误是否致命
3. 系统调用: 用户进程被置为阻塞态

### 模式切换

> 模式切换可以不改变正处于运行态的进程状态，保存和恢复上下文环境开销小；
> 进程切换涉及进程状态的变化，开销较大。

非特权：用户态  
特权：系统态、控制态、内核态

### Linux的fork

从fork中返回时，测试返回参数：

- 若值为0，则是子进程，可以转移到相应的用户程序中继续执行；
- 若值不为0（子进程的PID），则是父进程，继续执行主程序。

## 第四章 线程

### 特点

1. 进程包含两个特点：
   - 资源所有权：进程拥有对资源的控制权或所有权。
   - 调度/执行：进程是一个可被操作系统调度和分派的单位。
2. 进程的两个特点是独立的，操作系统可以独立地对其进行处理。
   - 线程（轻量级进程）：分派（调度运行）的单位。
   - 进程（任务）：拥有资源所有权的单位。

### 优点

- 在一个已有进程中创建一个新线程比创建一个全新进程所需的时间少很多。
- 终止一个线程比终止一个进程花费的时间少。
- 同一进程内线程间切换比进程间切换花费的时间少。
- 线程提高了不同的执行程序间通信的效率。

### 状态

1. 线程的关键状态
    - 就绪
    - 运行
    - 阻塞

> 挂起态是一个进程级概念。如果一个进程被换出，由于他的所有线程都共享该进程的地址空间，因此他们必须都被换出

### 用户级线程

> 有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。

#### 优点：

- 线程切换不需要内核态特权；
- 调度可以是应用程序相关的；
- 用户级线程可以在任何操作系统中运行，不需要对底层内核进行修改以支持用户级线程。

#### 缺点：

- 当执行一个系统调用时，会阻塞进程中所有线程；
- 无法利用多处理技术。

### 内核级线程

> 有关线程管理的工作由内核完成，应用程序只有一个到内核线程设施的应用程序编程接口。

#### 优点

- 内核可同时把同一进程中的多个线程调度到多个处理器中；
- 若进程中的一个线程被阻塞，内核可以调度同一进程中的另一个线程；
- 内核例程本身也可以使用多线程。

#### 缺点
在把控制从一个线程传送到同一个进程内的另一个线程时，需要内核的状态切换。

## 第五章 同步与互斥

### 部分术语

1. 原子操作
   - 保证指令序列要么作为一个组来执行，要么都不执行；
2. **临界区**
    - 一段代码，在这段代码中进程将访问共享资源，当一个进程已经在这段代码中运行时，另外一个进程就不能在这段代码中执行；
3. 死锁
    - 两个或两个以上的进程因其中的每个进程都在等待其他进程做完某些事情而不能继续执行；
4. 活锁
    - 两个或两个以上进程为了响应其他进程中的变化而持续改变自己的状态但不做有用的工作；
5. 互斥
    - 当一个进程在临界区访问共享资源时，其他进程不能进入该临界区访问任何共享资源；
6. 竞争条件
    - 多个线程或进程在读写一个共享数据时，结果依赖于它们执行的相对时间；
7. 饥饿
    - 一个可运行的进程被调度程序无限期地忽略，不能被调度执行的情形。

### 进程的交互

- 进程间的资源竞争
  - 互斥、死锁、饥饿
- 进程间通过共享合作
  - 互斥、死锁、饥饿、数据一致性
- 进程间通过通信合作
  - 死锁、饥饿

### 信号量

#### 基本原理

- 两个或多个进程通过简单的信号进行合作，一个进程被迫在某一位置停止，直到它接收到一个特定的信号。
- 任何复杂的合作需求都可以通过适当的信号结构得到满足。

#### 信号量是一个与队列有关的整型变量。

- 可以初始化成非负数；
- semWait操作使信号量减1。若值为负数，则执行semWait的进程阻塞，否则继续执行；
- semSignal操作使信号量加1。若值小于或等于0，则被semWait操作阻塞的进程被解除阻塞。

``` c++
struct semaphore {
    int count;
    queryType queue;
};
void semWait(semaphore s) {
    s.count--;
    if (s.count<0) {
        /* place this process in s.queue */;
        /* block this process */
    }
}
void semSignal(semphore s) {
    s.count++;
    if (s.count<=0) {
        /* remove a process P from s.queue */;
        /* place process P on ready list */;
    }
}
```

##### 生产者/消费者问题

问题描述：

- 有一个或多个生产者生产某种类型的数据，并放置在缓冲区中；
- 有一个消费者从缓冲区中取数据，每次取一项；
- 系统保证避免对缓冲区的重复操作，即任何时候只有一个主体（生产者或消费者）可以访问缓冲区。
- 缓存已满时，生产者不能继续添加数据；
- 缓存已空时，消费者不能继续移走数据。

``` c++
// 无限缓冲
semaphore n=0,s=1;
void producer(){
    while (true) {
        produce();
        semWait(s);
        append();
        semSignal(s);
        semSignal(n);
    }
}
void consumer(){
    while (true) {
        semWait(n);
        semWait(s);
        take();
        semSignal(s);
        consume();
    }
}
// 有限缓冲
semaphore n=0,s=1,e=buf-size;
void producer(){
    while (true) {
        produce();
        semWait(e);
        semWait(s);
        append();
        semSignal(s);
        semSignal(n);
    }
}
void consumer(){
    while (true) {
        semWait(n);
        semWait(s);
        take();
        semSignal(s);
        semSignal(e);
        consume();
    }
}
```

##### 读者/写者问题

问题定义

- 有一个由多个进程共享的数据区，一些进程只读取这个数据区中的数据，一些进程只往数据区中写数据。并须满足以下条件：
- 任意多的读进程可以同时读文件；
- 一次只有一个写进程可以写文件；
- 如果一个写进程正在写文件，那么禁止任何读进程读文件。
- **读者优先：只要有读进程在读，就为读进程保留数据区的控制权。**
- **写者优先：当写进程想写的时候，不允许新的读进程再访问数据区。**

``` c++
// 读者优先
int readcount=0;
semaphore x=1,wsem=1;
void reader() {
    while (true) {
        semWait(x);
        readcount++;
        if(readcount==1)
            semWait(wsem);
        semSignal(x);
        READUNIT();
        semWait(x);
        readcount--;
        if(readcount==0)
            semSignal(wsem);
        semSignal(x);
    }
}
void writer(){
    while (true) {
        semWait(wsem);
        WRITEUNIT();
        semSignal(wsem);
    }
}
// 写者优先
int readcount=0;
    writecount=0;
semaphore x=1,y=1,z=1,rsem=1,wsem=1;
void reader(){
    while (true) {
        semWait(z);
        semWait(rsem);
        semWait(x);
        readcount++;
        if(readcount==1)
            semWait(wsem);
        semSignal(x);  
        semSignal(rsem);
        semSignal(z);
        READUNIT();
        semWait(x);
        readcount--;
        if(readcount==0)
            semSignal(wsem);
        semSignal(x);
    }
}
void writer(){
    while (true) {
        semWait(y);
        writecount++;
        if(writecount==1)
            semWait(rsem);
        semSignal(y);  
        semWait(wsem);
        WRITEUNIT();
        semSignal(wsem);
        semWait(y);
        writecount--;
        if(writecount==0)
            semSignal(rsem);
        semSignal(y);  
    }
}
```

#### 小结

- 多个semWait操作的次序不能颠倒，否则可能导致死锁
- 多个semSignal操作的次序可任意

### 消息传递

1. 消息传递：合作进程之间进行信息交换。
2. 消息传递原语
    - send (destination, message)
    - receive (source, message)

#### 同步

1. 阻塞send,阻塞receive
    - 发送者和接收者都被阻塞，直到完成信息的投递。
2. **无阻塞send,阻塞receive**
    - 接收者阻塞，直到请求的信息到达。
3. 无阻塞send,无阻塞receive
    - 不要求任何一方等待。

## 第六章

> 1. 死锁：一组相互竞争系统资源或进行通信的进程间的永久阻塞。
> 2. 死锁问题没有一种有效的通用解决方案。
> 3. 所有死锁都涉及两个或多个进程之间对资源需求的冲突。

### 资源分配图

![资源分配图](../res/6.png)
![资源分配图](../res/7.png)

### 死锁条件

1. 互斥
    - 一次只有一个进程可以使用一个资源。
2. 占有且等待
    - 当一个进程等待其他进程时，继续占有已经分配的资源。
3. 不可抢占
    - 不能强行抢占进程已占有的资源。
4. 循环等待
    - 存在一个封闭的进程链，使得每个进程至少占有此链中下一个进程所需要的一个资源。

### 处理死锁的方法

#### 死锁预防

##### 试图设计一种系统来排除发生死锁的可能性。

- 间接的死锁预防方法
- 预防前三个条件

##### 直接的死锁预防方法

- 预防第四个条件

1. 互斥
    - 该条件不可能被禁止
2. 占有且等待
    - 可要求进程一次性地请求所有需要的资源，并且阻塞进程直到所有请求都同时满足。
    - 存在的问题：
        - 一个进程可能被阻塞很长时间，已等待满足其所有的资源请求。
        - 分配给一个进程的资源可能有相当长的一段时间不会被使用。
        - 一个进程可能事先并不知道它所需要的全部资源。
3. 不可抢占
    - 如果占有某些资源的进程进一步申请资源时被拒绝，则该进程必须释放它最初占有的资源。
    - 如果进程A请求当前被进程B占有的一个资源，则操作系统可以抢占进程B，要求它释放资源。
4. 循环等待
    - 定义资源类型的线性顺序。如果一个进程已经分配到了R类型的资源，那么它接下来请求的资源只能是那些排在R类型之后的资源类型。
    - 存在的问题：
        - 会导致进程执行速度变慢；
        - 可能在没有必要的情况下拒绝资源访问。

#### 死锁避免

- 如果一个进程的请求会导致死锁，则不启动此进程；
- 如果一个进程增加的资源请求会导致死锁，则不允许此分配。

##### 进程启动拒绝—数据结构

系统有n个进程和m种不同类型的资源：

- Resource=R=(R1,R2,…,Rm)
  - 系统中每种资源的总量
- Available=V=(V1,V2,…Vm)
  - 未分配给进程的每种资源的总量  
- $
Claim=C=
    \left \{
        \begin{matrix}
            C_{11} & C_{12} & … & C_{1m} \\
            C_{21} & C_{22} & … & C_{2m} \\
            …  & … & … & … \\
            C_{n1} & C_{n2} & … & C_{nm} \\
        \end{matrix}
    \right \}
$
  - Cij表示进程i对资源j的需求

###### 死锁避免策略

- 仅当 $R_j≥C_{(n+1)j} +\sum^n_{i=1} C_{ij} （对所有j）$时，才启动一个新进程Pn+1。
- 即只有所有当前进程的最大请求量加上新的进程请求可以满足时，才会启动该进程。

##### 资源分配拒绝

- 主要思想：动态的检测资源分配状态以确保循环等待条件不可能成立。

###### 银行家算法

- 银行家拥有一笔周转资金
- 客户要求分期贷款，如果客户能够得到各期贷款，就一定能够归还贷款，否则就一定不能归还贷款
- 银行家应谨慎的贷款，防止出现坏帐

> 用银行家算法避免死锁
>
> - 操作系统（银行家）
> - 操作系统管理的资源(周转资金)
> - 进程(要求贷款的客户)

1. 安全状态

    ![安全状态](../res/8.jpg)

    - 安全状态不是死锁状态
    - 死锁状态是不安全状态
    - 不是所有不安全状态都是死锁状态

2. 数据结构
    - Available：Available[j]=k
        - 资源类型Rj 现有k个实例
    - Claim： Claim[i,j]=k
        - 进程Pi最多可申请k个Rj的实例
    - Allocation：Allocation[i,j]=k
        - 进程Pi现在已经分配了k个Rj的实例
    - Need：Need[i,j]=k
        - 进程Pi还可能申请k个Rj的实例
        - Need[i,j] = Claim[i,j] - Allocation[i,j]

    >符号说明
    > - X<=Y
    >   - （X和Y是长度为n的向量），当且仅当对所有i=1,2,…,n，X[i]<=Y[i]
    > - Allocationi
    >   - 表示分配给进程Pi的资源（将Allocation每行作为向量）
    > - Need同Allocation

##### 死锁避免的优缺点

- 优点
  - 不需要死锁预防中的抢占和回滚进程
  - 比死锁预防的限制少
- 缺点
  - 必须事先声明每个进程请求的最大资源。
  - 进程必须是无关的，其执行的顺序必须没有任何同步要求的限制。
  - 分配的资源数目必须是固定的。
  - 在占有资源时，进程不能退出。

#### 死锁检测

> 死锁检测策略不限制资源访问或约束进程行为。
> 系统周期性地执行检测算法，检测循环等待条件是否成立。

##### 死锁检测算法

- 检测时机
  - 每个资源请求发生时
  - 隔一段时间
- 每次资源请求时检测死锁
  - 优点：可以尽早地检测死锁情况
  - 缺点：频繁的检查会耗费相当多的处理器时间

###### 死锁检测的常用算法

- 新定义一个请求矩阵Q
  1. 标记Allocaiton矩阵中一行全为零的进程。
  2. 初始化一个临时向量W，令W等于Available向量。
  3. 查找下标i，使进程i当前未标记且Q的第i行小于等于W，如果找不到这样的行，终止算法。
  4. 如果找到这样的行，标记进程i，并把Allocation矩阵中的相应行加到W中，返回步骤3.
- **若最后有未标记的进程时，存在死锁，每个未标记的进程都是死锁的。**

#### 恢复

1. 取消所有死锁进程。
2. 把每个死锁进程回滚到某些检查点，并重新启动所有进程。
3. 连续取消死锁进程直到不再存在死锁。选择取消进程的顺序基于某种最小代价原则。每次取消后，必须重新调用检测算法，以测试是否仍存在死锁。
4. 连续抢占资源直到不再存在死锁。同3。

#### 哲学家就餐问题

![哲学家就餐问题](../res/9.png)

``` c++
// 有死锁的version
semphore fork[5]={1};
int i;
void philosopher(int i) {
    while (true) {
        think();
        wait(fork[i]);
        wait(fork[(i+1)%5]);
        eat();
        signal(fork[(i+1)%5]);
        signal(fork[i]);
    }
}
// 没有死锁的version
semphore fork[5]={1};
semphore room=5;
int i;
void philosopher(int i) {
    while (true) {
        think();
        wait(room);
        wait(fork[i]);
        wait(fork[(i+1)%5]);
        eat();
        signal(fork[(i+1)%5]);
        signal(fork[i]);
        signal(room);
    }
}
```
