# OS  

## 第一章

### 基本指令周期

![基本指令周期](../res/1.jpg)  

>PC保存下一指令地址
>IR指令寄存器

### 中断

中断是一种机制，即允许其它模块（I/O、存储器）在处理器正常处理过程中打断其工作  

#### 中断分类

- 程序中断
- 时钟中断
- I/O中断
- 硬件失效中断

#### 中断和指令周期  

![中断和指令周期](../res/2.jpg)

#### 中断处理

![中断处理](../res/3.jpg)

##### 多中断

- 顺序中断处理: 当正在处理一个中断时，禁止中断
- 嵌套中断处理: 定义中断优先级，允许高优先级的中断打断低优先级的中断处理程序的运行

### 访问的局部性原理

在执行程序期间，处理器的指令访存和数据访存呈现“簇”状(一组数据集合)

#### 二级存取平均时间

cache A, 内存B, 命中率C  
$A*C+(A+B)*(1-C)$  

### I/O操作三种可能的技术

- 可编程I/O
- 中断驱动I/O
- 直接内存存取（DMA）

## 第二章

> 操作系统是控制应用程序执行的程序，并充当应用程序和计算机硬件之间的接口

### OS类型

#### 多道批处理系统

- 内存同时保存多个程序，当一个作业需要等待I/O时，处理器可以切换到另一个不需要等待I/O的作业。
- 提高CPU的利用率。
- 需要中断技术、内存管理、进程调度等方面的支持

#### 分时系统

- 允许多个联机用户同时使用一个计算机系统进行交互式计算。
- 时钟中断，时间片技术

## 第三章 进程描述和控制

>进程定义
>
>- 一个正在执行中的程序。
>- 一个正在计算机上执行的程序实例。
>- 能分配给处理器并由处理器执行的实体。
>- 一个具有以下特征的活动单元：一组指令序列的执行、一个当前状态和相关的系统资源集。
>
>构成进程的基本元素
>
>- 程序代码
>- 数据集
>
>进程控制块(pcb)

### 五态模型、带两挂起

![五态模型](../res/4.jpg)

![带两挂起](../res/5.jpg)

### 进程映像

|项目|说明|
|---|---|
|用户数据|用户空间中的可修改部分，包括程序数据、用户栈区域和可修改的程序|
|用户程序|将被执行的程序|
|系统栈|每个进程有一个或多个系统栈，用于保存参数、过程调用地址和系统调用地址|
|进程控制块|操作系统控制进程所需要的数据|

#### 进程控制块(PCB)

进程标识信息

- 进程ID、父进程ID、用户ID

进程状态信息

- 用户可见寄存器、控制和状态寄存器、栈指针

进程控制信息

- 调度和状态信息、数据结构、进程通信、进程特权、存储管理、资源的所有权和使用情况

### 进程创建

创建进程的步骤

1. 分配进程标识符
2. 分配空间
3. 初始化进程控制块
4. 设置正确的连接
5. 创建或扩充其它数据结构

### 进程切换

> 进程切换是让处于运行态的进程中断运行，让出处理器，让操作系统指定的新进程运行。被中断进程的上下文环境需要保存。

#### 切换时机

1. 中断
   - 时钟中断
   - I/O中断
   - 内存失效
2. 陷阱: 操作系统确定错误是否致命
3. 系统调用: 用户进程被置为阻塞态

### 模式切换

> 模式切换可以不改变正处于运行态的进程状态，保存和恢复上下文环境开销小；
> 进程切换涉及进程状态的变化，开销较大。

非特权：用户态  
特权：系统态、控制态、内核态

### Linux的fork

从fork中返回时，测试返回参数：

- 若值为0，则是子进程，可以转移到相应的用户程序中继续执行；
- 若值不为0（子进程的PID），则是父进程，继续执行主程序。

## 第四章 线程

### 特点

1. 进程包含两个特点：
   - 资源所有权：进程拥有对资源的控制权或所有权。
   - 调度/执行：进程是一个可被操作系统调度和分派的单位。
2. 进程的两个特点是独立的，操作系统可以独立地对其进行处理。
   - 线程（轻量级进程）：分派（调度运行）的单位。
   - 进程（任务）：拥有资源所有权的单位。

### 优点

- 在一个已有进程中创建一个新线程比创建一个全新进程所需的时间少很多。
- 终止一个线程比终止一个进程花费的时间少。
- 同一进程内线程间切换比进程间切换花费的时间少。
- 线程提高了不同的执行程序间通信的效率。

### 状态

1. 线程的关键状态
    - 就绪
    - 运行
    - 阻塞

> 挂起态是一个进程级概念。如果一个进程被换出，由于他的所有线程都共享该进程的地址空间，因此他们必须都被换出

### 用户级线程

> 有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。

#### 优点：

- 线程切换不需要内核态特权；
- 调度可以是应用程序相关的；
- 用户级线程可以在任何操作系统中运行，不需要对底层内核进行修改以支持用户级线程。

#### 缺点：

- 当执行一个系统调用时，会阻塞进程中所有线程；
- 无法利用多处理技术。

### 内核级线程

> 有关线程管理的工作由内核完成，应用程序只有一个到内核线程设施的应用程序编程接口。

#### 优点

- 内核可同时把同一进程中的多个线程调度到多个处理器中；
- 若进程中的一个线程被阻塞，内核可以调度同一进程中的另一个线程；
- 内核例程本身也可以使用多线程。

#### 缺点
在把控制从一个线程传送到同一个进程内的另一个线程时，需要内核的状态切换。

## 第五章 同步与互斥

### 部分术语

1. 原子操作
   - 保证指令序列要么作为一个组来执行，要么都不执行；
2. **临界区**
    - 一段代码，在这段代码中进程将访问共享资源，当一个进程已经在这段代码中运行时，另外一个进程就不能在这段代码中执行；
3. 死锁
    - 两个或两个以上的进程因其中的每个进程都在等待其他进程做完某些事情而不能继续执行；
4. 活锁
    - 两个或两个以上进程为了响应其他进程中的变化而持续改变自己的状态但不做有用的工作；
5. 互斥
    - 当一个进程在临界区访问共享资源时，其他进程不能进入该临界区访问任何共享资源；
6. 竞争条件
    - 多个线程或进程在读写一个共享数据时，结果依赖于它们执行的相对时间；
7. 饥饿
    - 一个可运行的进程被调度程序无限期地忽略，不能被调度执行的情形。

### 进程的交互

- 进程间的资源竞争
  - 互斥、死锁、饥饿
- 进程间通过共享合作
  - 互斥、死锁、饥饿、数据一致性
- 进程间通过通信合作
  - 死锁、饥饿

### 信号量

#### 基本原理

- 两个或多个进程通过简单的信号进行合作，一个进程被迫在某一位置停止，直到它接收到一个特定的信号。
- 任何复杂的合作需求都可以通过适当的信号结构得到满足。

#### 信号量是一个与队列有关的整型变量。

- 可以初始化成非负数；
- semWait操作使信号量减1。若值为负数，则执行semWait的进程阻塞，否则继续执行；
- semSignal操作使信号量加1。若值小于或等于0，则被semWait操作阻塞的进程被解除阻塞。

``` c++
struct semaphore {
    int count;
    queryType queue;
};
void semWait(semaphore s) {
    s.count--;
    if (s.count<0) {
        /* place this process in s.queue */;
        /* block this process */
    }
}
void semSignal(semphore s) {
    s.count++;
    if (s.count<=0) {
        /* remove a process P from s.queue */;
        /* place process P on ready list */;
    }
}
```

##### 生产者/消费者问题

问题描述：

- 有一个或多个生产者生产某种类型的数据，并放置在缓冲区中；
- 有一个消费者从缓冲区中取数据，每次取一项；
- 系统保证避免对缓冲区的重复操作，即任何时候只有一个主体（生产者或消费者）可以访问缓冲区。
- 缓存已满时，生产者不能继续添加数据；
- 缓存已空时，消费者不能继续移走数据。

``` c++
// 无限缓冲
semaphore n=0,s=1;
void producer(){
    while (true) {
        produce();
        semWait(s);
        append();
        semSignal(s);
        semSignal(n);
    }
}
void consumer(){
    while (true) {
        semWait(n);
        semWait(s);
        take();
        semSignal(s);
        consume();
    }
}
// 有限缓冲
semaphore n=0,s=1,e=buf-size;
void producer(){
    while (true) {
        produce();
        semWait(e);
        semWait(s);
        append();
        semSignal(s);
        semSignal(n);
    }
}
void consumer(){
    while (true) {
        semWait(n);
        semWait(s);
        take();
        semSignal(s);
        semSignal(e);
        consume();
    }
}
```

##### 读者/写者问题

问题定义

- 有一个由多个进程共享的数据区，一些进程只读取这个数据区中的数据，一些进程只往数据区中写数据。并须满足以下条件：
- 任意多的读进程可以同时读文件；
- 一次只有一个写进程可以写文件；
- 如果一个写进程正在写文件，那么禁止任何读进程读文件。
- **读者优先：只要有读进程在读，就为读进程保留数据区的控制权。**
- **写者优先：当写进程想写的时候，不允许新的读进程再访问数据区。**

``` c++
// 读者优先
int readcount=0;
semaphore x=1,wsem=1;
void reader() {
    while (true) {
        semWait(x);
        readcount++;
        if(readcount==1)
            semWait(wsem);
        semSignal(x);
        READUNIT();
        semWait(x);
        readcount--;
        if(readcount==0)
            semSignal(wsem);
        semSignal(x);
    }
}
void writer(){
    while (true) {
        semWait(wsem);
        WRITEUNIT();
        semSignal(wsem);
    }
}
// 写者优先
int readcount=0;
    writecount=0;
semaphore x=1,y=1,z=1,rsem=1,wsem=1;
void reader(){
    while (true) {
        semWait(z);
        semWait(rsem);
        semWait(x);
        readcount++;
        if(readcount==1)
            semWait(wsem);
        semSignal(x);  
        semSignal(rsem);
        semSignal(z);
        READUNIT();
        semWait(x);
        readcount--;
        if(readcount==0)
            semSignal(wsem);
        semSignal(x);
    }
}
void writer(){
    while (true) {
        semWait(y);
        writecount++;
        if(writecount==1)
            semWait(rsem);
        semSignal(y);  
        semWait(wsem);
        WRITEUNIT();
        semSignal(wsem);
        semWait(y);
        writecount--;
        if(writecount==0)
            semSignal(rsem);
        semSignal(y);  
    }
}
```

#### 小结

- 多个semWait操作的次序不能颠倒，否则可能导致死锁
- 多个semSignal操作的次序可任意

### 消息传递

1. 消息传递：合作进程之间进行信息交换。
2. 消息传递原语
    - send (destination, message)
    - receive (source, message)

#### 同步

1. 阻塞send,阻塞receive
    - 发送者和接收者都被阻塞，直到完成信息的投递。
2. **无阻塞send,阻塞receive**
    - 接收者阻塞，直到请求的信息到达。
3. 无阻塞send,无阻塞receive
    - 不要求任何一方等待。

## 第六章

> 1. 死锁：一组相互竞争系统资源或进行通信的进程间的永久阻塞。
> 2. 死锁问题没有一种有效的通用解决方案。
> 3. 所有死锁都涉及两个或多个进程之间对资源需求的冲突。

### 资源分配图

![资源分配图](../res/6.png)
![资源分配图](../res/7.png)

### 死锁条件

1. 互斥
    - 一次只有一个进程可以使用一个资源。
2. 占有且等待
    - 当一个进程等待其他进程时，继续占有已经分配的资源。
3. 不可抢占
    - 不能强行抢占进程已占有的资源。
4. 循环等待
    - 存在一个封闭的进程链，使得每个进程至少占有此链中下一个进程所需要的一个资源。

### 处理死锁的方法

#### 死锁预防

##### 试图设计一种系统来排除发生死锁的可能性。

- 间接的死锁预防方法
- 预防前三个条件

##### 直接的死锁预防方法

- 预防第四个条件

1. 互斥
    - 该条件不可能被禁止
2. 占有且等待
    - 可要求进程一次性地请求所有需要的资源，并且阻塞进程直到所有请求都同时满足。
    - 存在的问题：
        - 一个进程可能被阻塞很长时间，已等待满足其所有的资源请求。
        - 分配给一个进程的资源可能有相当长的一段时间不会被使用。
        - 一个进程可能事先并不知道它所需要的全部资源。
3. 不可抢占
    - 如果占有某些资源的进程进一步申请资源时被拒绝，则该进程必须释放它最初占有的资源。
    - 如果进程A请求当前被进程B占有的一个资源，则操作系统可以抢占进程B，要求它释放资源。
4. 循环等待
    - 定义资源类型的线性顺序。如果一个进程已经分配到了R类型的资源，那么它接下来请求的资源只能是那些排在R类型之后的资源类型。
    - 存在的问题：
        - 会导致进程执行速度变慢；
        - 可能在没有必要的情况下拒绝资源访问。

#### 死锁避免

- 如果一个进程的请求会导致死锁，则不启动此进程；
- 如果一个进程增加的资源请求会导致死锁，则不允许此分配。

##### 进程启动拒绝—数据结构

系统有n个进程和m种不同类型的资源：

- Resource=R=(R1,R2,…,Rm)
  - 系统中每种资源的总量
- Available=V=(V1,V2,…Vm)
  - 未分配给进程的每种资源的总量  
- $
Claim=C=
    \left \{
        \begin{matrix}
            C_{11} & C_{12} & … & C_{1m} \\
            C_{21} & C_{22} & … & C_{2m} \\
            …  & … & … & … \\
            C_{n1} & C_{n2} & … & C_{nm} \\
        \end{matrix}
    \right \}
$
  - Cij表示进程i对资源j的需求

###### 死锁避免策略

- 仅当 $R_j≥C_{(n+1)j} +\sum^n_{i=1} C_{ij} （对所有j）$时，才启动一个新进程Pn+1。
- 即只有所有当前进程的最大请求量加上新的进程请求可以满足时，才会启动该进程。

##### 资源分配拒绝

- 主要思想：动态的检测资源分配状态以确保循环等待条件不可能成立。

###### 银行家算法

- 银行家拥有一笔周转资金
- 客户要求分期贷款，如果客户能够得到各期贷款，就一定能够归还贷款，否则就一定不能归还贷款
- 银行家应谨慎的贷款，防止出现坏帐

> 用银行家算法避免死锁
>
> - 操作系统（银行家）
> - 操作系统管理的资源(周转资金)
> - 进程(要求贷款的客户)

1. 安全状态

    ![安全状态](../res/8.jpg)

    - 安全状态不是死锁状态
    - 死锁状态是不安全状态
    - 不是所有不安全状态都是死锁状态

2. 数据结构
    - Available：Available[j]=k
        - 资源类型Rj 现有k个实例
    - Claim： Claim[i,j]=k
        - 进程Pi最多可申请k个Rj的实例
    - Allocation：Allocation[i,j]=k
        - 进程Pi现在已经分配了k个Rj的实例
    - Need：Need[i,j]=k
        - 进程Pi还可能申请k个Rj的实例
        - Need[i,j] = Claim[i,j] - Allocation[i,j]

    >符号说明
    > - X<=Y
    >   - （X和Y是长度为n的向量），当且仅当对所有i=1,2,…,n，X[i]<=Y[i]
    > - Allocationi
    >   - 表示分配给进程Pi的资源（将Allocation每行作为向量）
    > - Need同Allocation

##### 死锁避免的优缺点

- 优点
  - 不需要死锁预防中的抢占和回滚进程
  - 比死锁预防的限制少
- 缺点
  - 必须事先声明每个进程请求的最大资源。
  - 进程必须是无关的，其执行的顺序必须没有任何同步要求的限制。
  - 分配的资源数目必须是固定的。
  - 在占有资源时，进程不能退出。

#### 死锁检测

> 死锁检测策略不限制资源访问或约束进程行为。
> 系统周期性地执行检测算法，检测循环等待条件是否成立。

##### 死锁检测算法

- 检测时机
  - 每个资源请求发生时
  - 隔一段时间
- 每次资源请求时检测死锁
  - 优点：可以尽早地检测死锁情况
  - 缺点：频繁的检查会耗费相当多的处理器时间

###### 死锁检测的常用算法

- 新定义一个请求矩阵Q
  1. 标记Allocaiton矩阵中一行全为零的进程。
  2. 初始化一个临时向量W，令W等于Available向量。
  3. 查找下标i，使进程i当前未标记且Q的第i行小于等于W，如果找不到这样的行，终止算法。
  4. 如果找到这样的行，标记进程i，并把Allocation矩阵中的相应行加到W中，返回步骤3.
- **若最后有未标记的进程时，存在死锁，每个未标记的进程都是死锁的。**

#### 恢复

1. 取消所有死锁进程。
2. 把每个死锁进程回滚到某些检查点，并重新启动所有进程。
3. 连续取消死锁进程直到不再存在死锁。选择取消进程的顺序基于某种最小代价原则。每次取消后，必须重新调用检测算法，以测试是否仍存在死锁。
4. 连续抢占资源直到不再存在死锁。同3。

#### 哲学家就餐问题

![哲学家就餐问题](../res/9.png)

``` c++
// 有死锁的version
semphore fork[5]={1};
int i;
void philosopher(int i) {
    while (true) {
        think();
        wait(fork[i]);
        wait(fork[(i+1)%5]);
        eat();
        signal(fork[(i+1)%5]);
        signal(fork[i]);
    }
}
// 没有死锁的version
semphore fork[5]={1};
semphore room=5;
int i;
void philosopher(int i) {
    while (true) {
        think();
        wait(room);
        wait(fork[i]);
        wait(fork[(i+1)%5]);
        eat();
        signal(fork[(i+1)%5]);
        signal(fork[i]);
        signal(room);
    }
}
```

## 第七章

### 内存分区

#### 固定分区

##### 分区大小

- 大小相等的分区
  - 程序可能太大而不能放到一个分区中
  - 内存的利用率非常低，会有**内部碎片**
- 大小不等的分区
  - 可缓解上述问题，但不能完全解决。

##### 固定分区放置算法

- 大小相等的分区
  - 只要存在可用的分区，进程就可以装入分区。
  - 若所有分区都被处于不可运行状态的进程所占据，则选择其中一个进程换出，为新进程让出空间。
- 大小不等的分区
  - 把每个进程分配到能够容纳它的最小分区。
    - 每个分区维护一个调度队列，用于保存从这个分区换出的进程。
    - 为所有进程只提供一个队列。

##### 固定分区方案的缺陷

- 分区的数目在系统生成阶段已经确定，限制了系统中活动进程的数目。
- 分区大小在系统生成阶段事先设置，小作业不能有效地利用分区空间。

#### 动态分区

- 分区长度和数目是可变的，当进程被装入内存时，系统会给它分配一块和它所需容量完全相等的内存空间。
- 缺陷
  - **外部碎片**
- 外部碎片解决方法
  - 压缩
  - 费时且浪费处理器时间

##### 放置算法

- 首次适配（First Fit）
  - 从开始扫描内存，选择大小足够的第一个可用块；
- 下次适配（Next Fit）
  - 首次适配的变种，每次分配时从未分配区的上次扫描结束处顺序查找，选择下一个大小足够的可用块。
- 最佳适配（Best Fit）
  - 选择与要求的大小最接近的块。
- 最差适配（Worst Fit）
  - 选择符合要求大小的最大容量的块。

#### 伙伴系统

- 伙伴系统是一种固定分区和可变分区折中的主存管理算法。
- 伙伴系统分配原理
  - 可用于分配的整个空间被视为一个大小为2U的块，若请求的大小s满足2U-1﹤s≤2U,则分配整个空间；
  - 否则，该块被分成两个大小相等的伙伴2U-1，如果有2U-2﹤s≤2U-1 ，则给该请求分配两个伙伴中的任何一个，否则，其中一个伙伴又被分成两半……，该过程一直继续，直到产生大于或等于s的最小块。

### 分页

- 内存被划分成大小固定相等的块（**页框**），且块相对比较小，每个进程也被分成同样大小的块（**页**）。
- 进程中称为页的块可以指定到内存中称为页框的可用块。
- 分页与固定分区的区别
  - 分页技术的分区相当小
  - 一个程序可以占据多个分区
  - 一个程序占据的多个分区不需要是连续的

### 分段

- 把程序和其相关的数据划分到几个段中。
- 段有一个最大长度限制，但不要求所有程序的所有段的长度都相等。
- 分段与动态分区的区别
  - 一个程序可以占据多个分区
  - 一个程序占据的多个分区不需要是连续的
  - 会产生外部碎片，但跟动态分区比，会很小

### 逻辑地址到物理地址转换

- 段表：将逻辑地址映射为物理地址
- 段基地址：包含该段在内存中的开始物理地址
- 段界限：指定该段的长度
- 逻辑地址：段号s＋段内偏移d
- 逻辑地址到物理地址的转换
  1. 段号与段表长度进行比较，若段号超过了段表长度，则越界（非法地址），否则转2)
  2. 根据段表始址和段号计算出该段对应段表项的位置，从中读出该段在内存的起始地址，检查段内地址是否超过该段的段长，若超过则越界（非法地址），否则转3)
  3. 将该段的起始地址与段内位移相加，从而得到要访问的物理地址

### 储存的保护

- 保护操作系统不受用户进程所影响，保护用户进程不受其他用户进程所影响
- 方法
  1. 存储键保护
     - 系统将主存划分成大小相等的若干存储块，并给每个存储块都分配一个单独的保护键（锁）；在程序状态字PSW中设置有保护键字段，对不同的作业赋予不同的代码（钥匙）；钥匙和锁相配才允许访问
  2. 界限寄存器（下页图）
     - 上、下界防护：硬件为分给用户作业的连续的主存空间设置一对上、下界，分别指向该存储空间的上、下界
     - 基址、限长防护：基址寄存器存放当前正执行者的程序地址空间所占分区的始址，限长寄存器存放该地址空间的长度
    ![1](../res/11.jpg)
