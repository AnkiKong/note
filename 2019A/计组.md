# 机组

## 第一章

### 冯·诺依曼型计算机

- 存储程序
- 按地址自动执行
- **五大部件**：包括控制器、运算器、存储器、输入设备、输出设备
- 以运算器为中心
- ![ahh](../res/20.png)

> 冯.诺伊曼思想（二进制表示信息、存储程序、按地址访问）

### 计算机系统的层次结构

- 五级计算机层次系统
  1. 第一级是**微程序设计级**。这是一个实在的硬件级，它由机器硬件直接执行微指令。如果某一个应用程序直接用微指令来编写，那么可在这一级上运行应用程序。
  2. 第二级是**一般机器级**，也称为机器语言级，它由微程序解释机器指令系统。这一级也是硬件级。
  3. 第三级是**操作系统级**，它由操作系统程序实现。这些操作系统由机器指令和广义指令组成，广义指令是操作系统定义和解释的软件指令，所以这一级也称为混合级。
  4. 第四级是**汇编语言级**，它给程序人员提供一种符号形式语言，以减少程序编写的复杂性。这一级由汇编程序支持和执行。如果应用程序采用汇编语言编写时，则机器必须要有这一级的功能；如果应用程序不采用汇编语言编写，则这一级可以不要。
  5. 第五级是**高级语言级**，它是面向用户的，为方便用户编写应用程序而设置的。这一级由各种高级语言编译程序支持和执行。

## 第二章

### IEEE754

![ieee754](../res/21.png)

- S：浮点数的符号位，1 位，0表示正数，1表示负数。
- M：尾数，23/52位(32/64位浮点数)，小数表示，小数点放在尾数域的最前面。
- E：阶码8/11位(32/64位浮点数),阶符采用隐含方式，即采用移码方式来表示正负指数。移码方法对两个指数大小的比较和对阶操作都比较方便，因为阶码域值大者其指数值也大。采用这种方式时，将浮点数的指数真值e变成阶码Ｅ 时，应将指数e 加上一个固定的偏移值127(01111111)/1023，(01111111111)即
                          E＝e＋127       (32位浮点数)
                          E＝e＋1023     (64位浮点数)
　　IEEE754 标准中，一个规格化的32位浮点数ｘ的真值可表示为
　　　　$ x＝(－1)s×(1.M)×2^{E－127}　　　 　e＝E－127 $
　　一个规格化的64位浮点数ｘ的真值为
　　　　$ x＝(－1)s×(1.M)×2^{E－1023} 　　  e＝E－1023 $
- 规格化表示：尾数域最高有效位要为1
  - $ 1.1xxx,0.1xxx $

### 各种码

- 原码：符号位+二进制
- 反码：~原码
- 补码
  - 加法：直接加
  - 减法：加负减数得补码
- 移码：补码最高为取反

#### 溢出检测

1. 符号扩展，$V=S_{f1} \bigoplus S_{f2}$, V=1表示有溢出，01上溢，10下溢
2. 无论溢出与否，$S_{f1}$始终指示正确符号

### 加法器

1. 第0类加法器
   - $S_i=A_i \bigoplus B_i \bigoplus C_i $
   - $ C_{i+1}=A_iB_i+B_iC_i+C_iA_i $
   - n位串行进位加法器延迟：$ t_a=(2n+9)T $

![jiafaqi](../res/23.png)

### 乘法器

> 对于两个原码数，数值部分直接运算，也就是说原码乘法，算前求补和算后求补都不需要  
> 对于两个补码数，先算前求补，经阵列乘法后算后求补，这种补码运算是间接的补码乘法

![chengfaqi](../res/22.jpg)

#### 直接补码乘法

- **符号位权值为-1**

### 除法器

#### 不恢复余数的阵列乘法器

- 被除数：$ 0.x_1x_2x_3x_4x_5x_6 $ **(整数位一定要是0)**
  - 除数的两倍长
- 除数：$ 0.y_1y_2y_3 $ **(整数位一定要是0)**
  - 被除数的一半
- 商：$ 0.q_1q_2q_3 $
  - 除数等长
- 余数：$ 0.00r_3r_4r_5r_6 $
- 符号位提出来，后面讨论
- 除法器  
![chufaqi](../res/24.png)
- 原码除法运算  
![bala](../res/25.png)  

> 商的最后如果是0，余数取最后一个商为1的余数

### 浮点加法、减法运算

1. 0操作数检查
2. 比较阶码大小并完成对阶
3. 尾数求和运算
4. 结果规格化
5. 舍入处理
6. 溢出处理

#### 舍入处理

- 补码舍入规则：
  1. 当丢失的各位均为0时，不必舍入
  2. 当丢失的最高位为0，以下各位不全为0时，或者丢失的最高位为1，以下各位均为0时，则舍去丢失位上的值
  3. 当丢失的最高位为1，以下各位不全为0时，在尾数最低位入1的修正操作。

> 丢失的位，最高位为1且非最高位不全为0，则修正

### 运算流水线

- 一个k级流水线处理n个任务需要的时钟数为：$ T_k=k+(n-1) $
- 非流水线处理n个任务需要的时钟数为：$ T_L=nk $
- 线性流水线的加速比：$ C_k = \frac{T_L}{T_k}=\frac{nk}{k+(n-1)} $

## 第三章

### 主存储器的技术指标

> 字存储单元、字节存储单元、按字寻址和按字节寻址

1. 存取时间
2. 存储周期
3. 存储器带宽

### SRAM存储器

1. 基本存储元
![blaaaa](../res/26.png)

2. SRAM存储器的组成
   - SRAM存储器主要由存储体、读写电路、地址译码电路和控制电路

> CS片选信号。WE写使能信号。OE输出使能信号  
> $ t_{RC} = t_{WC} $ 读周期=写周期，存取周期  

### 多模块交叉存储器

#### 存储器的模块化组织

1. 顺序方式
   ![blaa](../res/27.png)
2. 交叉方式
   ![blla](../res/28.png)
3. ???
   ![ahhh](../res/29.png)

### cache基本原理

1. cache的功能
   - 主要解决CPU和主存之间速度不匹配的问题。

![moe](../res/30.jpg)

#### 主存与cache的地址映射

1. 全相联映射方式
   - ![aff](../res/31.jpg)
   - 暴力扫一遍
2. 直接相联映射方式
   - ![adf](../res/32.jpg)
   - 指定位置
3. 组相联映射方式
   - ![enn](../res/33.jpg)
   - 1对一组

### 虚拟存储器的基本概念

- 虚拟存储器中的逻辑地址到物理地址的转换是由硬件实现的存储管理部件MMU来完成的

## 第四章

### 指令系统的发展与性能要求

- 对指令系统的要求
  - 完备性
  - 有效性
  - 规整性
  - 兼容性

### 指令格式

- 影响计算机指令格式的因素
  - 机器的字长
  - 存储器的容量
  - 指令的功能
- 指令能反映以下信息
  - 做什么操作
  - 如果需要操作数，从哪里取
  - 结果送哪里
  - 下一条指令从哪里取
- 所以指令格式包括两个方面：
  - ![ahh](../res/34.png)

#### 地址码

- 根据一条指令中有几个操作数地址，可将该指令称为几操作数指令或几地址指令。
  - 三地址指令
  - 二地址指令
  - 单地址指令
  - 零地址指令
- ![ahh](../res/35.png)

##### 三地址指令

- 指令格式如下：
- ![ahh](../res/36.png)
- 操作码θ   第一操作数A1   第二操作数A2      结果A3
- 功能描述
  - (A1)θ(A2)→A3
  - (PC) +1→PC
- 这种格式虽然省去了一个地址，但指令长度仍比较长，所以只在字长较长的大、中型机中使用，而小型、微型机中很少使用。

##### 二地址指令

- 其格式如下：
  - ![ahh](../res/37.png)
- 操作码θ第一操作数A1第二操作数A2
- 功能描述：
  - (A1)θ(A2)→A1
  - (PC)+1→PC
- 二地址指令在计算机中得到了广泛的应用，但是在使用时有一点必须注意：指令执行之后，A1中原存的内容已经被新的运算结果替换了。
- 二地址地址根据操作数的物理位置分为：
  - SS 存储器-存储器类型(慢)
  - RS 寄存器-存储器类型
  - RR 寄存器-寄存器类型(快)

##### 一地址指令

- 指令格式为
- ![ahh](../res/38.png)
- 操作码θ     第一操作数A1
- 功能描述
  - (AC)θ(A1) →A1
  - (PC)+1→PC
- 单操作数运算指令，如“+1”、“-1”、“求反”
- 指令中给出一个源操作数的地址

##### 零地址指令  

- 其格式为：
- ![ahh](../res/39.png)
- 操作码θ
- “停机”、“空操作”、“清除”等控制类指令。

#### 指令长度

- 概念
  - 指令字长度（一个指令字包含二进制代码的位数）
  - 机器字长：计算机能直接处理的二进制数据的位数。
  - 单字长指令
  - 半字长指令
  - 双字长指令
- 多字长指令的优缺点
  - 优点提供足够的地址位来解决访问内存任何单元的寻址问题 ；
  - 缺点必须两次或多次访问内存以取出一整条指令，降低了CPU的运算速度，又占用了更多的存储空间。
- 指令系统中指令采用等长指令的优点：各种指令字长度是相等的，指令字结构简单，且指令字长度是不变的 ；
- 采用非等长指令的的优点：各种指令字长度随指令功能而异，结构灵活，能充分利用指令长度，但指令的控制较复杂 。

### ARM

- 格式

|cond|F|I|opcode|S|Rn|Rd|operand 2|
|----|-|-|------|-|--|--|---------|
|4位|2位|1位|4位|1位|4位|4位|12位|

- opcode：操作码
- Rd：目标寄存器
- Rn：源寄存器
- operand 2：第二个源操作数
- I：立即数；0：第二个操作数在寄存器中；1：第二个操作数是12位立即数
- S：指明状态，涉及条件转移指令
- cond：指明条件：涉及条件转移指令
- F：说明指令类型

### RISC

- 特点（采用流水线技术）
  - 简单而统一格式的指令译码；
  - 大部分指令可以单周期执行
  - 只有LOAD/STORE可以访问存储器
  - 简单的寻址方式
  - 采用延迟转移技术
  - 采用LOAD延迟技术
  - 三地址指令格式
  - 较多的寄存器
  - 对称的指令格式

## 第五章

### CPU的功能和组成

1. CPU的功能
   - ![a](../res/40.png)
   - 指令控制（程序的顺序控制）
   - 操作控制（一条指令有若干操作信号实现）
   - 时间控制（指令各个操作实施时间的定时）
   - 数据加工（算术运算和逻辑运算）
2. CPU的基本组成
   - ![a](../res/41.png)
   - 中央处理器CPU=运算器+控制器
     - 运算器
       - ALU
       - 累加器
       - 暂存器
     - 控制器
       - 程序计数器、指令寄存器、数据缓冲器、地址寄存器、通用寄存器、状态寄存器、时序发生器、指令译码器、总线（数据通路）

### 操作控制器和时序产生器

- 硬布线控制器
  - 硬布线控制器，它是采用组合逻辑技术来实现的，其时序控制信号形成部件是由门电路组成的复杂树形网络。这种方法是分立元件时代的产物，以使用最少器件数和取得最高操作速度为设计目标。
  - 组合逻辑控制器的最大优点是速度快，但是时序控制信号形成部件的结构不规整，使得设计、调试、维修较困难，难以实现设计自动化。

### 指令周期

#### 指令周期的基本概念

- 概念
  - **指令周期**：指取指令、分析指令到执行完该指令所需的全部时间。
  - **机器周期** 通常又称 **CPU周期**，**时钟周期**
    - 通常把一条**指令周期**划分为若干个**机器周期**，每个机器周期完成一个基本操作。
    - 主存的 **工作周期(存取周期)** 为基础来规定 **CPU周期**，比如，可以用CPU读取一个指令字的最短时间来规定CPU周期
    - 不同的指令，可能包含不同数目的机器周期。
    - 一个机器周期中，包含若干个机器周期（节拍脉冲或T脉冲）。
    - CPU周期规定，不同的计算机中规定不同
    - 在一个机器周期内，要完成若干个微操作。这些微操作有的可以同时执行，有的需要按先后次序串行执行。因而需要把一个机器周期分为若干个相等的时间段，每一个时间段称为一个节拍。节拍常用具有一定宽度的电位信号表示，称之为节拍电位。
    - 节拍的宽度取决于CPU完成一次基本的微操作的时间，如：ALU完成一次正确的运算，寄存器间的一次数据传送等。
- ![blaa](../res/42.png)

#### meow

- MOV指令的指令周期
  - ![mov](../res/43.png)
- LAD指令的指令周期
  - ![load](../res/44.png)
- ADD指令的指令周期
  - ![add](../res/45.jpg)
- STO指令的指令周期
  - ![store](../res/45.png)
- JMP指令的指令周期
  - ![jmp](../res/46.png)
  - `offset = addr - @ - 1, @:目标地址`

#### 用方框图语言表示的指令周期

- 方法：
  - 指令系统设计（模型机的五指令系统）
  - `方框`: 按CPU周期
  - `方框内内容`: 数据通路操作或控制操作
  - `菱形符号`: 判别或测试
  - `~`: 公操作
  - 前边所讲述的5种操作的框图描述
  - ![f?](../res/47.png)

### 微程序控制器

> 基本思想：仿照解题的方法，把操作控制信号编制成微指令，存放到控制存储器里，运行时，从控存中取出微指令，产生指令运行所需的操作控制信号。从上述可以看出，微程序设计技术是用软件方法来设计硬件的技术

#### 微程序控制原理

- 微命令：控制部件向执行部件发出的各种控制命令叫作微命令，它是构成控制序列的最小单位。
  - 例如：打开或关闭某个控制门的电位信号、某个寄存器的打入脉冲等。
  - 微命令是控制计算机各部件完成某个基本微操作的命令。
- 微操作：是微命令的操作过程。
  - 微命令和微操作是一一对应的。
  - 微命令是微操作的控制信号，微操作是微命令的操作过程。
  - 微操作是执行部件中最基本的操作。
  - 由于数据通路的结构关系，微操作可分为相容的和互斥的两种：
    - 互斥的微操作，是指不能同时或不能在同一个节拍内并行执行的微操作。可以编码
    - 相容的微操作，是指能够同时或在同一个节拍内并行执行的微操作。必须各占一位
- 微指令：把在同一CPU周期内并行执行的微操作控制信息，存储在控制存储器里，称为一条微指令（`Microinstruction`）
  - 它是微命令的组合，微指令存储在控制器中的控制存储器中
  - 一条微指令通常至少包含两大部分信息
    - 操作控制字段，又称微操作码字段，用以产生某一步操作所需的各个微操作控制信号。
      - 某位为1，表明发微指令
      - 微指令发出的控制信号都是节拍电位信号，持续时间为一个CPU周期
      - 微命令信号还要引入时间控制
    - 顺序控制字段，又称微地址码字段，用以控制产生下一条要执行的微指令地址。
- 微程序
  - 一系列微指令的有序集合就是微程序。
    - 一段微程序对应一条机器指令。
    - 微地址 ：存放微指令的控制存储器的单元地址
  - ![ah](../res/49.jpg)

##### 微程序控制器原理

- ![50](../res/50.jpg)
- 控制存储器(`μCM`)
  - 这是微程序控制器的核心部件，用来存放微程序。其性能(包括容量、速度、可靠性等)与计算机的性能密切相关
- 微指令寄存器(`μIR`)
  - 用来存放从`μCM`取出的正在执行的微指令，它的位数同微指令字长相等。
- 微地址形成部件
  - 用来产生初始微地址和后继微地址，以保证微指令的连续执行。
- 微地址寄存器(`μMAR`)
  - 它接受微地址形成部件送来的微地址，为下一步从`μCM`中读取微指令作准备。
- 微程序控制器的工作过程
  1. 执行取指令的公共操作。取指令的公共操作通常由一段取指微程序来完成，在机器开始运行时，自动将取指微程序的入口微地址送`μMAR`，并从`μCM`中读出相应的微指令送入`μIR`。微指令的操作控制字段产生有关的微命令，用来控制实现取机器指令的公共操作。取指微程序的入口地址一般为`μCM`的0号单元，当取指微程序执行完后，从主存中取出的机器指令就已存人指令寄存器`IR`中了。
  2. 由机器指令的操作码字段通过微地址形成部件产生出该机器指令所对应的微程序的入口地址，并送入`μMA`
  3. 从`μCM`中逐条取出对应的微指令并执行之，每条微指令都能自动产生下一条微指令的地址
  4. 一条机器指令对应的微程序的最后一条微指令执行完毕后，其下一条微指令地址又回到取指微程序的人口地址，从而继续第(1)步，以完成取下条机器指令的公共操作

##### CPU周期和微指令周期的关系

- ![51](../res/51.png)

#### 机器指令与微指令的关系

- ![52](../res/52.png)










